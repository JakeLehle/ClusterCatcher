"""
ClusterCatcher Snakemake Pipeline
=================================

Single-cell sequencing analysis pipeline for:
1. Cell Ranger alignment and counting
2. Scanpy QC and cell filtering
3. Cell type annotation (popV/CellTypist)
4. Dysregulation detection (CytoTRACE2 + inferCNV)
5. Viral detection in unmapped reads (Kraken2)
6. Somatic mutation calling (SComatic)
7. Mutational signature deconvolution (semi-supervised NMF)

Configuration is loaded from the YAML file specified at runtime.
"""

import os
from pathlib import Path

# ============================================================================
# Configuration
# ============================================================================

configfile: "config.yaml"

# Extract configuration values
OUTPUT_DIR = config.get("output_dir", "results")
TEMP_DIR = config.get("temp_dir", "tmp")
LOG_DIR = config.get("log_dir", "logs")
THREADS = config.get("threads", 8)

# Sample information
SAMPLES = config.get("samples", {})
SAMPLE_IDS = list(SAMPLES.keys())

# Reference paths
TRANSCRIPTOME_REF = config.get("reference", {}).get("transcriptome")
GENOME_BUILD = config.get("reference", {}).get("genome", "GRCh38")
REFERENCE_FASTA = config.get("reference", {}).get("fasta")
KRAKEN2_DB = config.get("viral_detection", {}).get("kraken2_db")

# Feature flags
VIRAL_DETECTION_ENABLED = config.get("viral_detection", {}).get("enabled", False)
SCOMATIC_ENABLED = config.get("scomatic", {}).get("enabled", False)
SIGNATURES_ENABLED = config.get("signatures", {}).get("enabled", False)

# Scripts directory
SCRIPTS_DIR = Path(workflow.basedir) / "scripts"

# ============================================================================
# Helper Functions
# ============================================================================

def get_fastq_r1(wildcards):
    """Get R1 FASTQ files for a sample."""
    sample_info = SAMPLES.get(wildcards.sample, {})
    return sample_info.get("fastq_r1", [])

def get_fastq_r2(wildcards):
    """Get R2 FASTQ files for a sample."""
    sample_info = SAMPLES.get(wildcards.sample, {})
    return sample_info.get("fastq_r2", [])

def get_all_bams():
    """Get all BAM files from Cell Ranger output."""
    return expand(
        f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/possorted_genome_bam.bam",
        sample=SAMPLE_IDS
    )

def get_final_targets():
    """Generate list of final target files based on configuration."""
    targets = []
    
    # Cell Ranger outputs
    targets.extend(expand(
        f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/filtered_feature_bc_matrix.h5",
        sample=SAMPLE_IDS
    ))
    
    # QC and annotation outputs
    targets.append(f"{OUTPUT_DIR}/qc/multiqc_report.html")
    targets.append(f"{OUTPUT_DIR}/annotation/adata_annotated.h5ad")
    targets.append(f"{OUTPUT_DIR}/annotation/annotation_summary.tsv")
    
    # Dysregulation outputs (cancer cell detection)
    targets.append(f"{OUTPUT_DIR}/dysregulation/dysregulation_summary.tsv")
    targets.append(f"{OUTPUT_DIR}/dysregulation/adata_cancer_detected.h5ad")
    
    # Conditional targets
    if VIRAL_DETECTION_ENABLED:
        targets.append(f"{OUTPUT_DIR}/viral/viral_detection_summary.tsv")
        # Viral integration (if human viral db provided)
        if config.get("viral_detection", {}).get("human_viral_db"):
            targets.append(f"{OUTPUT_DIR}/viral_integration/adata_with_virus.h5ad")
            targets.append(f"{OUTPUT_DIR}/viral_integration/viral_integration_summary.tsv")
        
    if SCOMATIC_ENABLED:
        targets.append(f"{OUTPUT_DIR}/mutations/somatic_mutations.vcf.gz")
        
    if SIGNATURES_ENABLED:
        targets.append(f"{OUTPUT_DIR}/signatures/signature_weights.tsv")
        
    # Master summary
    targets.append(f"{OUTPUT_DIR}/master_summary.yaml")
    
    return targets

# ============================================================================
# Rules
# ============================================================================

rule all:
    """Target rule specifying all final outputs."""
    input:
        get_final_targets()

# ----------------------------------------------------------------------------
# Cell Ranger Rules
# ----------------------------------------------------------------------------

rule cellranger_count:
    """
    Run Cell Ranger count for a single sample.
    
    This rule aligns FASTQ files to the reference transcriptome and generates
    gene expression matrices. Uses automatic chemistry detection with fallback
    options if the specified chemistry fails.
    
    Note: Cell Ranger must be installed separately and available in PATH.
    See: https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest
    """
    output:
        matrix=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/filtered_feature_bc_matrix.h5",
        bam=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/possorted_genome_bam.bam",
        bai=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/possorted_genome_bam.bam.bai",
        summary=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/web_summary.html",
    params:
        transcriptome=TRANSCRIPTOME_REF,
        chemistry=config.get("cellranger", {}).get("chemistry", "auto"),
        expect_cells=config.get("cellranger", {}).get("expect_cells"),
        include_introns=config.get("cellranger", {}).get("include_introns", True),
        localcores=config.get("cellranger", {}).get("localcores", THREADS),
        localmem=config.get("cellranger", {}).get("localmem", 32),
        create_bam=config.get("cellranger", {}).get("create_bam", True),
    log:
        f"{LOG_DIR}/cellranger/{{sample}}.log"
    threads: THREADS
    conda:
        "envs/sc_pre.yaml"
    script:
        "scripts/cellranger_count.py"

# ----------------------------------------------------------------------------
# QC and Annotation Rules (Combined)
# ----------------------------------------------------------------------------

rule qc_and_annotation:
    """
    Combined QC filtering and cell type annotation.
    
    This rule performs:
    1. Loading Cell Ranger outputs
    2. QC filtering (genes, counts, mitochondrial content)
    3. Doublet removal (Scrublet)
    4. Normalization and preprocessing
    5. Dimensionality reduction (PCA, UMAP)
    6. Clustering (Leiden)
    7. Cell type annotation (popV)
    """
    input:
        cellranger_dirs=expand(
            f"{OUTPUT_DIR}/cellranger/{{sample}}",
            sample=SAMPLE_IDS
        ),
    output:
        adata=f"{OUTPUT_DIR}/annotation/adata_annotated.h5ad",
        qc_metrics=f"{OUTPUT_DIR}/qc/qc_metrics.tsv",
        annotation_summary=f"{OUTPUT_DIR}/annotation/annotation_summary.tsv",
        figures=directory(f"{OUTPUT_DIR}/figures"),
    params:
        qc_params=config.get("qc", {}),
        preprocessing_params=config.get("preprocessing", {}),
        annotation_params=config.get("annotation", {}),
    log:
        f"{LOG_DIR}/qc_annotation/qc_annotation.log"
    threads: THREADS
    conda:
        "envs/sc_pre.yaml"
    script:
        "scripts/scanpy_qc_annotation.py"

rule multiqc:
    """Generate MultiQC report from all QC outputs."""
    input:
        cellranger=expand(
            f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/web_summary.html",
            sample=SAMPLE_IDS
        ),
        qc_metrics=f"{OUTPUT_DIR}/qc/qc_metrics.tsv",
    output:
        report=f"{OUTPUT_DIR}/qc/multiqc_report.html",
    params:
        outdir=f"{OUTPUT_DIR}/qc",
    log:
        f"{LOG_DIR}/qc/multiqc.log"
    conda:
        "envs/sc_pre.yaml"
    shell:
        """
        multiqc {params.outdir} -o {params.outdir} -n multiqc_report.html 2>&1 | tee {log}
        """

# ----------------------------------------------------------------------------
# Cancer Cell Detection Rules (CytoTRACE2 + InferCNV)
# ----------------------------------------------------------------------------

rule cancer_cell_detection:
    """
    Detect cancer cells using dual-model approach.
    
    This rule:
    1. Runs CytoTRACE2 for stemness/potency scoring
    2. Uses CytoTRACE2 threshold to define reference normal cells
    3. Runs inferCNV using normal cells as reference
    4. Calculates weighted agreement between models
    5. Classifies cells as Cancer/Normal based on agreement
    
    Requires: GTF annotation file for chromosomal information
    """
    input:
        adata=f"{OUTPUT_DIR}/annotation/adata_annotated.h5ad",
    output:
        adata=f"{OUTPUT_DIR}/dysregulation/adata_cancer_detected.h5ad",
        summary=f"{OUTPUT_DIR}/dysregulation/cancer_detection_summary.tsv",
        figures=directory(f"{OUTPUT_DIR}/dysregulation/figures"),
    params:
        gtf_path=config.get("reference", {}).get("gtf"),
        species=config.get("dysregulation", {}).get("cytotrace2", {}).get("species", "human"),
        max_cells_chunk=config.get("dysregulation", {}).get("cytotrace2", {}).get("max_cells_per_chunk", 200000),
        infercnv_window=config.get("dysregulation", {}).get("infercnv", {}).get("window_size", 250),
        agreement_alpha=config.get("dysregulation", {}).get("agreement", {}).get("alpha", 0.5),
        min_correlation=config.get("dysregulation", {}).get("agreement", {}).get("min_correlation", 0.5),
    log:
        f"{LOG_DIR}/dysregulation/cancer_detection.log"
    threads: THREADS
    conda:
        "envs/sc_post.yaml"
    script:
        "scripts/cancer_cell_detection.py"

rule dysregulation_summary:
    """
    Generate summary of dysregulation analysis.
    
    Combines CytoTRACE2, inferCNV, and cancer classification results.
    """
    input:
        adata=f"{OUTPUT_DIR}/dysregulation/adata_cancer_detected.h5ad",
        cancer_summary=f"{OUTPUT_DIR}/dysregulation/cancer_detection_summary.tsv",
    output:
        summary=f"{OUTPUT_DIR}/dysregulation/dysregulation_summary.tsv",
    log:
        f"{LOG_DIR}/dysregulation/summary.log"
    run:
        import pandas as pd
        import scanpy as sc
        
        # Load data
        adata = sc.read_h5ad(input.adata)
        cancer_summary = pd.read_csv(input.cancer_summary, sep='\t')
        
        # Create comprehensive summary
        summary_data = {
            'total_cells': adata.n_obs,
            'cancer_cells': (adata.obs['Final_cancer_cell_status'] == 'Cancer cell').sum(),
            'normal_cells': (adata.obs['Final_cancer_cell_status'] == 'Normal cell').sum(),
            'mean_cytotrace_score': adata.obs['CytoTRACE2_Score'].mean(),
            'mean_cnv_score': adata.obs['cnv_score'].mean(),
            'mean_agreement_score': adata.obs['agreement_score'].mean(),
            'cytotrace_threshold': cancer_summary['cytotrace_threshold'].iloc[0],
            'agreement_threshold': cancer_summary['agreement_threshold'].iloc[0],
            'spearman_correlation': cancer_summary['spearman_correlation'].iloc[0],
        }
        
        # Add cell type breakdown
        if 'final_annotation' in adata.obs.columns:
            cancer_by_type = adata.obs[adata.obs['Final_cancer_cell_status'] == 'Cancer cell']['final_annotation'].value_counts()
            for ct, count in cancer_by_type.items():
                summary_data[f'cancer_cells_{ct}'] = count
        
        pd.DataFrame([summary_data]).to_csv(output.summary, sep='\t', index=False)

rule combine_dysregulation:
    """
    Combine CytoTRACE2 and inferCNV results to identify dysregulated cells.
    
    Cells with both high stemness and chromosomal instability are flagged.
    """
    input:
        cytotrace=f"{OUTPUT_DIR}/dysregulation/cytotrace2_scores.tsv",
        infercnv=f"{OUTPUT_DIR}/dysregulation/infercnv_scores.tsv",
        adata=f"{OUTPUT_DIR}/annotation/cell_annotations.h5ad",
    output:
        summary=f"{OUTPUT_DIR}/dysregulation/dysregulation_summary.tsv",
        adata=f"{OUTPUT_DIR}/dysregulation/dysregulation_annotated.h5ad",
    log:
        f"{LOG_DIR}/dysregulation/combine.log"
    conda:
        "envs/scanpy.yaml"
    script:
        "scripts/combine_dysregulation.py"

# ----------------------------------------------------------------------------
# Viral Detection Rules (Kraken2)
# ----------------------------------------------------------------------------

rule kraken2_detect:
    """
    Detect viral/microbial sequences in unmapped reads using Kraken2.
    
    This rule:
    1. Extracts unmapped reads from Cell Ranger BAM
    2. Runs Kraken2 classification
    3. Builds single-cell count matrix linking barcodes to organisms
    
    Requires: Kraken2 database (see README for setup instructions)
    """
    input:
        bam=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/possorted_genome_bam.bam",
        bai=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/possorted_genome_bam.bam.bai",
    output:
        summary=f"{OUTPUT_DIR}/viral/{{sample}}/{{sample}}_organism_summary.tsv",
        matrix_dir=directory(f"{OUTPUT_DIR}/viral/{{sample}}/kraken2_filtered_feature_bc_matrix"),
    params:
        db_path=KRAKEN2_DB,
        confidence=config.get("viral_detection", {}).get("confidence", 0.0),
        include_organisms=config.get("viral_detection", {}).get("include_organisms"),
        exclude_organisms=config.get("viral_detection", {}).get("exclude_organisms"),
    log:
        f"{LOG_DIR}/viral/{{sample}}_kraken2.log"
    threads: THREADS
    conda:
        "envs/kraken2.yaml"
    script:
        "scripts/kraken2_viral_detection.py"

rule summarize_viral:
    """
    Summarize viral detection results across all samples.
    
    Creates aggregated reports and a combined AnnData object for
    integration with cell annotations.
    """
    input:
        reports=expand(
            f"{OUTPUT_DIR}/viral/{{sample}}/{{sample}}_organism_summary.tsv",
            sample=SAMPLE_IDS
        ),
    output:
        summary=f"{OUTPUT_DIR}/viral/viral_detection_summary.tsv",
        adata=f"{OUTPUT_DIR}/viral/viral_counts.h5ad",
    params:
        sample_ids=SAMPLE_IDS,
        organisms_of_interest=config.get("viral_detection", {}).get("organisms_of_interest", []),
    log:
        f"{LOG_DIR}/viral/summarize.log"
    conda:
        "envs/kraken2.yaml"
    script:
        "scripts/summarize_viral_detection.py"

rule viral_integration:
    """
    Integrate viral detection results with annotated expression data.
    
    This rule:
    1. Merges viral counts with gene expression data
    2. Filters for human-specific viruses
    3. Calculates differential expression of viruses across cell types
    4. Creates visualizations
    5. Adds top virus to expression AnnData
    
    Requires: Human viral database inspect.txt file
    """
    input:
        adata_pp=f"{OUTPUT_DIR}/dysregulation/adata_cancer_detected.h5ad",
        viral_summary=f"{OUTPUT_DIR}/viral/viral_detection_summary.tsv",
    output:
        adata=f"{OUTPUT_DIR}/viral_integration/adata_with_virus.h5ad",
        integrated=f"{OUTPUT_DIR}/viral_integration/adata_viral_integrated.h5ad",
        summary=f"{OUTPUT_DIR}/viral_integration/viral_integration_summary.tsv",
        figures=directory(f"{OUTPUT_DIR}/viral_integration/figures"),
    params:
        sample_ids=SAMPLE_IDS,
        human_viral_db=config.get("viral_detection", {}).get("human_viral_db"),
        viral_base_dir=f"{OUTPUT_DIR}/viral",
    log:
        f"{LOG_DIR}/viral_integration/integration.log"
    threads: THREADS
    conda:
        "envs/sc_pre.yaml"
    script:
        "scripts/viral_integration.py"

# ----------------------------------------------------------------------------
# Somatic Mutation Rules (SComatic)
# ----------------------------------------------------------------------------

rule scomatic_basecalling:
    """
    Run SComatic Step 1: Base calling at single-cell level.
    """
    input:
        bam=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/possorted_genome_bam.bam",
        bai=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/possorted_genome_bam.bam.bai",
        barcodes=f"{OUTPUT_DIR}/cellranger/{{sample}}/outs/filtered_feature_bc_matrix/barcodes.tsv.gz",
    output:
        basecalls=directory(f"{OUTPUT_DIR}/mutations/scomatic/{{sample}}/BaseCellCounts"),
    params:
        reference=REFERENCE_FASTA,
        min_cov=config.get("scomatic", {}).get("min_cov", 5),
    log:
        f"{LOG_DIR}/mutations/{{sample}}_basecalling.log"
    threads: THREADS
    conda:
        "envs/scomatic.yaml"
    script:
        "scripts/scomatic_basecalling.py"

rule scomatic_merging:
    """
    Run SComatic Step 2: Merge base calling results.
    """
    input:
        basecalls=expand(
            f"{OUTPUT_DIR}/mutations/scomatic/{{sample}}/BaseCellCounts",
            sample=SAMPLE_IDS
        ),
    output:
        merged=f"{OUTPUT_DIR}/mutations/scomatic/merged_basecalls.tsv.gz",
    log:
        f"{LOG_DIR}/mutations/merging.log"
    conda:
        "envs/scomatic.yaml"
    script:
        "scripts/scomatic_merge.py"

rule scomatic_calling:
    """
    Run SComatic Step 3: Somatic mutation calling.
    """
    input:
        merged=f"{OUTPUT_DIR}/mutations/scomatic/merged_basecalls.tsv.gz",
        annotations=f"{OUTPUT_DIR}/annotation/cell_annotations.h5ad",
    output:
        mutations=f"{OUTPUT_DIR}/mutations/somatic_mutations.vcf.gz",
        mutation_matrix=f"{OUTPUT_DIR}/mutations/mutation_matrix.tsv",
    params:
        min_cells=config.get("scomatic", {}).get("min_cells", 5),
        min_cc=config.get("scomatic", {}).get("min_cc", 5),
        min_ar=config.get("scomatic", {}).get("min_ar", 0.1),
    log:
        f"{LOG_DIR}/mutations/calling.log"
    threads: THREADS
    conda:
        "envs/scomatic.yaml"
    script:
        "scripts/scomatic_calling.py"

# ----------------------------------------------------------------------------
# Mutational Signature Rules
# ----------------------------------------------------------------------------

rule prepare_mutation_contexts:
    """
    Extract trinucleotide contexts for each mutation.
    """
    input:
        mutations=f"{OUTPUT_DIR}/mutations/somatic_mutations.vcf.gz",
        reference=REFERENCE_FASTA,
    output:
        contexts=f"{OUTPUT_DIR}/signatures/trinucleotide_contexts.tsv",
        counts=f"{OUTPUT_DIR}/signatures/mutation_counts_per_cell.tsv",
    log:
        f"{LOG_DIR}/signatures/contexts.log"
    conda:
        "envs/signatures.yaml"
    script:
        "scripts/extract_contexts.py"

rule signature_deconvolution:
    """
    Run semi-supervised NMF for mutational signature deconvolution.
    
    Uses COSMIC signatures as seeds for the NMF decomposition.
    """
    input:
        contexts=f"{OUTPUT_DIR}/signatures/trinucleotide_contexts.tsv",
        counts=f"{OUTPUT_DIR}/signatures/mutation_counts_per_cell.tsv",
    output:
        weights=f"{OUTPUT_DIR}/signatures/signature_weights.tsv",
        plots=directory(f"{OUTPUT_DIR}/signatures/plots"),
        quality=f"{OUTPUT_DIR}/signatures/quality_metrics.tsv",
    params:
        cosmic_version=config.get("signatures", {}).get("cosmic_version", "3.4"),
        signatures=config.get("signatures", {}).get("relevant_signatures", []),
        min_mutations=config.get("signatures", {}).get("min_mutations", 10),
        metrics=config.get("signatures", {}).get("similarity_metrics", ["cosine"]),
    log:
        f"{LOG_DIR}/signatures/deconvolution.log"
    threads: THREADS
    conda:
        "envs/signatures.yaml"
    script:
        "scripts/signature_deconvolution.py"

# ----------------------------------------------------------------------------
# Summary Rules
# ----------------------------------------------------------------------------

rule master_summary:
    """
    Generate master summary YAML combining all pipeline results.
    """
    input:
        qc=f"{OUTPUT_DIR}/qc/qc_metrics.tsv",
        annotation=f"{OUTPUT_DIR}/annotation/annotation_summary.tsv",
        dysregulation=f"{OUTPUT_DIR}/dysregulation/dysregulation_summary.tsv",
        viral=f"{OUTPUT_DIR}/viral/viral_detection_summary.tsv" if VIRAL_DETECTION_ENABLED else [],
        mutations=f"{OUTPUT_DIR}/mutations/somatic_mutations.vcf.gz" if SCOMATIC_ENABLED else [],
        signatures=f"{OUTPUT_DIR}/signatures/signature_weights.tsv" if SIGNATURES_ENABLED else [],
    output:
        summary=f"{OUTPUT_DIR}/master_summary.yaml",
    params:
        config=config,
        sample_ids=SAMPLE_IDS,
    log:
        f"{LOG_DIR}/master_summary.log"
    script:
        "scripts/generate_summary.py"

